---
title: "Formas Funcionales 2.0"
author: "Carlos Jara"
date: "28 de enero de 2018"
output:
  html_document:
    css: C:/Users/carlo/Dropbox/Archivos de R/Apuntes de R/Estilo.css
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
    number_sections: true
    highlight: tango
editor_options: 
  chunk_output_type: console
---

```{r setup,echo=FALSE,message=FALSE,include=FALSE}
require("knitr")
#opts_knit$set(root.dir = normalizePath("d:/Archivos de la Facultad/Bases y Sintaxis Clases/Regresion Lineal/Formas Funcionales"))
opts_knit$set(root.dir = normalizePath("C:/Users/carlo/Dropbox/Archivos de Apuntes/Regresion Lineal/Formas Funcionales"))
knitr::opts_chunk$set(echo=FALSE)
``` 

```{r , results="asis",echo=FALSE}
options(knitr.table.format = "html")
options(knitr.kable.NA = '')
options("scipen"=999, "digits"=4)
```


```{r,message=FALSE,echo=FALSE,include=FALSE}
library ("knitr")
library ("kableExtra")
library ("foreign")
library("car")
library ("Hmisc")
library("scatterplot3d")
library("wooldridge")
library("readxl")
library("olsrr")
library("lrmest")
oldpar<-par(no.readonly = TRUE)
```

Hasta ahora hemos considerado modelos que son lineales **_tanto en los parámetros como en las variables_**, sin embargo, recordemos que la teoría de regresión de los capítulos anteriores solo exige linealidad en los parámetros; **_las variables pueden o no entrar linealmente en el modelo_**.

<h1>1 - Modelos logarítmicos y semilogaritmicos</h1>

<h2>Consideraciones Teóricas</h2>

Como su nombre bien lo dice, estos modelos involucran la aplicación de logaritmos sobre las variables originales.

+ Los modelos seran **_semilogaritmicos_** cuando la transformación sea sobre la variable dependiente o la/las independientes.  
+ Los modelos seran **_logaritmicos_** cuando la transformación sea de ambas variables.

Segun donde sea la transformación, estos modelos se denominan **_lin-log_**, **_log-lin_**,**_log-log_**.  

A los economistas, comerciantes y gobiernos con frecuencia les interesa encontrar **_la tasa de crecimiento_** de ciertas variables econ?micas, como poblaci?n, PNB, oferta monetaria, empleo, productividad o d?ficit comercial mas que analizar los volumenes o montos nominales. Es por esta razon que para obtener la **_tasa de variacion_** se aplica el logaritmo sobre la variable de interes.

La demostracion de esto se encuentra en "Econometria - Gujarati Pag 160 Pie de pagina

Para cada una de las funciones, vamos a calcular las derivadas primeras que van a determinar las pendientes de cada una de las funciones y luego calcularemos la elasticidad cada por $E~=~\frac{\partial Y}{\partial X}*\frac{X}{Y}$

$$Y~=~\beta_{0}~+~\beta_{1}*X$$

Su derivada esta dada por $\frac{\partial Y}{\partial X}=\beta_{1}$ 

Su elasticidad por $\beta_{1}*\frac{X}{Y}$ 

$$ln(Y)~=~\beta_{0}~+~\beta_{1}*X$$

Su derivada esta dada por:  $\frac{\partial (lnY)}{\partial X}=\beta_{1}\Rightarrow Y?*\frac{1}{Y}=\beta_{1}\Rightarrow \frac{\partial Y}{\partial X}=\beta_{1}*Y$ 

Su elasticidad por $\beta_{1}*Y*\frac{X}{Y}\Rightarrow E=\beta_{1}*X$ 

$$Y~=~\beta_{0}~+~\beta_{1}*ln(X)$$ 

Su derivada esta dada por: $\frac{\partial Y}{\partial (lnX)}=\frac{1}{X}*\beta_{1}$ 

Su elasticidad por $\beta_{1}*\frac{1}{X}*\frac{X}{Y}\Rightarrow E=\beta_{1}*\frac{1}{Y}$

$$ln(Y)~=~\beta_{0}~+~\beta_{1}*ln(X)$$ 

Su derivada esta dada por: $\frac{\partial Y}{\partial (lnX)}=\frac{1}{X}*\beta_{1}\Rightarrow Y?*\frac{1}{Y}=\frac{1}{X}* \beta_{1} \Rightarrow \frac{\partial Y}{\partial X}=\frac{Y}{X}*\beta_{1}$ 

Su elasticidad por $\beta_{1}*\frac{Y}{X}*\frac{X}{Y}\Rightarrow E=\beta_{1}$ conocido como "Modelo de elasticidad constante"

<h2>Cuando usar o no logaritmos</h2>

Wooldridge Introduccion a la Econometria Pag 194.

+ Cuando y es mayor que cero, las variables estrictamente positivas pueden tener distribuciones condicionales heterocedasticas o asimetricas, los logaritmos corrigen este defecto.
+ Disminuye el intervalo de variacion de la variable.
+ NO USAR cuando la variable dependiente fluctua entre 0 y 1, produce el efecto contrario al anterior, mas cuando los valores son proximos a cero.
+ Variable que miden cantidades monetarias (Sueldos, salarios, ventas) pueden usarse en logaritmos.
+ Variables que miden tiempo (antiguedad, edad, experiencia), NO USAR.
+ Variables que aparecen como tasas o porcentajes, NO USAR.

<h2>Modelo Lin-Log</h2>

Como dijimos anteriormente, estos modelo implican que la variable dependiente esta transformada a logaritmos manteniendose la independiente sin cambios.

Vamos a utilizar el ejercicio 8 del TP 3 donde se relaciona el precio de los papas con la demanda de papas.

Primero vemos los datos y luego vemos unas graficas exploratorias

```{r,echo=FALSE,include=FALSE}
formas<-spss.get("TP 5 Formas Funcionales.sav")
papas<-data.frame(formas$Y.Kg,formas$X.precio)
attach(papas)
colnames(papas)<-c("KgY","PrecioX");papas
```

```{r knitr, results="asis",echo=FALSE}
options(knitr.table.format = "html")
options(knitr.kable.NA = '')
kable(head(papas),align="c")%>%
  kable_styling(bootstrap_options=c("striped","borderer"), full_width = F)
```

```{r}
m<-boxplot(papas,main="Box Plot",col="green4",horizontal=TRUE)
v<-round(m$stats,2)
text(x=v[,1],y=1.5,labels=v[,1],cex=0.8)
text(x=v[,2],y=2.5,labels=v[,2],cex=0.8)
points(x=m$out,col="blue",pch=19,lwd=2,y=rep(1,length(m$out)))
points(x=mean(papas$KgY),y=1,col="red",pch=19)
points(x=mean(papas$PrecioX),y=2,col="red",pch=19)
```

Ahora vemos el grafico de dispersion

```{r,echo=FALSE}
reg<-lm(papas$KgY~papas$PrecioX)
plot(papas$PrecioX,papas$KgY,pch=19,col="red",xlab="Precio",ylab="Kg")
abline(coef = coef(reg),col="blue",lwd=2)
```

Vemos que si trazamos la recta de regresion sobre los datos, esta se desvia del sendero ideal dado por la nube de puntos, esta desviacion esta mas marcada en las colas que en el centro. 

```{r,echo=FALSE}
anova(reg)
summary(reg)
```
Vemos tambien las tablas de analisis donde, si bien los coeficientes son significativos, la bondad del ajuste no es tan buena.

Lo que podemos hacer, en principio, es aplicar logaritmos a la variable independiente, obteniendo la siguiente grafica y los siguientes resultados.

```{r,echo=FALSE}
reg1<-lm(papas$KgY~log(papas$PrecioX))
plot(log(papas$PrecioX),papas$KgY,pch=19,col="red",xlab="Precio",ylab="Kg")
abline(coef = coef(reg1),col="blue",lwd=2)
```
Vemos que los puntos toman un comportamiento mas lineal por lo que la recta de regresion permite un mejor ajuste. Esto se verifica a traves de las significatividades y la mejora en la bondad del ajuste.

```{r,echo=FALSE}
anova(reg1)
summary(reg1)
detach(papas)
```

Debemos tener en cuenta que podemos hacer una comparacion entre los modelos ya que **_la variable dependiente es exactamente la misma en ambas regresiones_**, el cambio de la variable dependiente por una transformacion hace que no puedan compararse los modelos directamente.

Lo que nosotros estamos utilizando para este caso es un modelo del tipo:

$$Y_{?}~=~\beta_{0}~+~\beta_{1}~ln~X_{i}~+~e_{i}$$

donde el coeficiente de la pendiente $\beta_{1}$ **_mide el cambio absoluto en el valor promedio de Y ante un cambio relativo o proporcionales de X_**.  
La interpretacion del coeficiente hallado presenta cambios respecto a un modelo lin_lin.

El coeficiente de la pendiente expresa $\beta_{1}~=~\frac{cambio~de~Y}{cambio~en~ln~X}=~\frac{cambio~de~Y}{cambio~relativo~en~X}$

Luego de aplicar la derivada $\beta_{1}~=~\frac{\Delta Y}{\Delta X /X}~\Rightarrow~\Delta Y=\beta_{1}*(\Delta X /X)$

<p class="four"> Esto quiere decir que si $\Delta X/X$ cambia 1% (0.01 unidades) entonces Y aumentara $\beta_{1}*0.01$ unidades o lo que es lo mismo **_dividimos el $\beta$ por 100_**, esto implica que $\beta_{1}$ pasa al dividir de % (por X) a Unidades (por Y) ya que la transformacion de X incremento el coeficiente</p>

$\Delta Y=(\beta_{1}/100)\%\Delta X$

"Cuando el precio de las papas (X) aumenta un **_1%_**, la cantidad demandada en Kg (Y) disminuira `r abs(reg1$coefficients[[2]]/100)`" (El coeficiente estimado de la pendiente se divide por 100)

En estos modelos donde se relacionan precio y demanda de un bien es tambien interesante el analisis de la eslasticidad que se define como:

$Elasticidad~precio~de~la~demanda=\frac{porcentaje~variacion~demanda}{porcentaje~variacion~precio}=\frac{\Delta Q /Q}{\Delta P /P}=\frac{\Delta Q}{\Delta P}*\frac{P}{Q}$

Para el modelo **_lin-log_** la elasticidad estara dada por $E=\frac{\Delta Q}{\Delta P}*\frac{1}{Q}$, es decir, la elasticidad varia ya que cada observacion tiene un valor de Y determinado.  

En terminos del modelo la elasticidad estara dada por $E_{p}~=\beta_{1}*\frac{1}{Q}$ = `r reg1$coefficients[[2]]`*$\frac{1}{Q}$

<h2>Modelo Log-Lin</h2>

La transformacion en este caso se realiza sobre la variable depediente Y (Kg).

Lo que nosotros estamos utilizando para este caso es un modelo del tipo:

$$ln~Y_{?}~=~\beta_{0}~+~\beta_{1}~X_{i}~+~e_{i}$$

donde el coeficiente de la pendiente $\beta_{1}$ **_mide el cambio relativo o porcentual en el valor promedio de Y ante un cambio absoluto de X_**.  

Realizamos el grafico y analizamos los resultados de la regresion.

```{r,echo=FALSE}
reg2<-lm(log(papas$KgY)~papas$PrecioX)
plot(papas$PrecioX,log(papas$KgY),pch=19,col="red",xlab="Precio",ylab="Ln Kg")
abline(coef = coef(reg2),col="blue",lwd=2)
```
```{r,echo=FALSE}
anova(reg2)
summary(reg2)
```

La interpretacion del coeficiente hallado en este modelo, en terminos del problema seria:

"Cuando el precio de las papas (X) aumenta 1 peso, la cantidad demandada en Kg (Y) disminuira `r abs(reg2$coefficients[[2]])*100` %" (El coeficiente estimado se multiplica por 100 para expresarlo como porcentaje)

<p class="four"> Esto quiere decir que si $\Delta X/X$ cambia 1 unidad entonces Y aumentara $\beta_{1}*100$ % o lo que es lo mismo **_multiplicamos el $\beta$ sobre 100_**, esto implica que $\beta_{1}$ pasa al multiplicarse de U (por X) a % (por Y) ya que la transformacion de Y disminuyo el coeficiente </p>

$\%\Delta Y=(100*\beta_{1})\Delta X$

Para el modelo **_log-lin_** la elasticidad estara dada por $E=\frac{\Delta Q}{\Delta P}*P$, es decir, la elasticidad varia ya que cada observacion tiene un valor de Y determinado.

En terminos del modelo la elasticidad estara dada por $E_{p}~=\beta_{1}* P$ = `r reg2$coefficients[[2]]` * P

<h2>Modelo Log-Log</h2>

Este modelo tambien es llamado **_Modelo de Elasticidad Constante por lo visto en la seccion de "Consideraciones Teoricas_**"

Uno de los mas modelos mas comunes utilizados mucho en Microeconomia es la funcion de Cobb-DOuglas que relaciona la produccion con el trabajo y el capital, para mas informacion, leer del siguiente link.

https://es.wikipedia.org/wiki/Funci%C3%B3n_de_producci%C3%B3n_de_Cobb-Douglas

El modelo esta dado por:

$Q_{t}~=~A~*~K_{t}^{\beta_{1}}~*~L_{t}^{\beta_{2}}~*~e^{ut}$

donde K=insumo Capital  T=insumo Trabajo y A=factor de productividad.

Para el analisis, usemos los datos del Ejercicio 4 del TP 4.

```{r,echo=FALSE}
cd<-formas[1:11,7:10]
attach(cd)
kable(cd,align="c")%>%
  kable_styling(bootstrap_options=c("striped","borderer"), full_width = F)
```
La funcion de Cobb-Douglas no es una funcion lineal pero se considera que es un **_modelo intrinsicamente linealizable_**, es decir, una transformacion de la misma permite obtener un modelo lineal en los parametros.

En terminos generales  $ln~Y_{?}~=~ln~\beta_{0}~+~\beta_{1}~ln~X_{i}~+~e_{i}$

En terminos del problema    $$ln~Q_{?}~=~ln~\beta_{0}~+~\beta_{1}~ln~K_{i}~+~\beta_{2}~ln~L_{i}~e_{i}$$

Vemos la grafica de los puntos y los resultados de la regresion obtenida.

```{r,echo=FALSE}
scatterplot3d(cd$K, cd$L, cd$Q, highlight.3d=TRUE, col.axis="blue",col.grid="lightblue", main="Funcion de Cobb-Douglas", xlab="Capital (K)",ylab="Trabajo (L)",zlab="Produccion (Q)",pch=20)
reg3<-lm(log(cd$Q)~log(cd$K)+log(cd$L))
anova(reg3)
summary(reg3)
detach(cd)
```

<h2>Aplicación practica del modelo de Cobb-Douglas</h2>

El objetivo es ver una aplicación practica de la función de Cobb-Douglas para datos de todos los países del mundo.
Esto se base en el video sobre estadístico de Wald

https://www.youtube.com/watch?v=J6oi1a4P7-0&list=PLE4a3phdCOav7rXE4RjOROGYBfdXHnIkJ&index=29

Los datos utilizados para el presente trabajo fueron obtenidos de:

"PWT version 10.0 is a database with information on relative levels of income, output, input and productivity, covering 183 countries between 1950 and 2019. Access to the data is provided below:"

https://www.rug.nl/ggdc/productivity/pwt/?lang=en

Para esto bajamos la base de datos en excel

```{r}
base<-read_xlsx("C:/Users/carlo/Dropbox/Archivos de Apuntes/Regresion Lineal/Formas Funcionales/Penn World Table Database.xlsx",sheet ="Data")
```

Una vez levantada la base, vamos a quedarnos con los datos del año 2019 para las variables Gross domestic product (GDP) (rgdpo), Poblacion en millones (pop) y Stock de Capital por PPC (cn)

```{r}
base<-subset(base,year==2019,select = c(pop,rgdpo,cn))
colnames(base)<-c("Poblacion","PBI","Capital")
```

Pasamos a logaritmos las variables para poder aplicar la funcion de Cobb-Douglas

```{r}
base<-log(base)
```

Hacemos la regresion de los datos

```{r}
reg<-ols_regress(PBI~Poblacion+Capital,data=base)
reg
```

Una vez realizada la estimación de los coeficientes, debemos verificar si que ocurre con los rendimientos a escala, si los mismos son decrecientes, constantes o crecientes, dependiendo esto de que valor toma la suma de los coeficientes.

En caso que sea decreciente, significa que si duplicamos el capital y la fuerza laboral, el incremento en el PBI (GDP) sera menor al doble.

Para esto vamos a utilizar los conocidos contrastes de restricciones. Debemos tener en cuenta que esta funcion requiere un objeto "lm"

Prueba de contraste basado en la F
```{r,echo=TRUE}
reg<-lm(PBI~Poblacion+Capital,data=base)
linearHypothesis(reg,c("Poblacion+Capital=1"))
```

Prueba de contraste basado en Wald con una restricción

```{r}
linearHypothesis(reg,c("Poblacion+Capital=1"),test="Chisq")
```

Vemos que dado el P-Value obtenido, se rechaza la H0 que los coeficientes son iguales a uno por lo tanto el análisis empírico permite determinar que el conjunto de los países analizados poseen rendimientos a escala crecientes.

El creador del video realiza una prueba adicional para determinar si el volumen de capital es cuatro veces mayor al de trabajo.
Realizamos esta prueba para ver como se arma:

```{r,echo=TRUE}
linearHypothesis(reg,c("4*Poblacion-Capital=0"),test="Chisq")
```

Tambien podemos hacer las regresion bajo la suposición que los rendimientos son constantes a escala, es decir, la suma de los coeficientes de "Población" y "Capital" es uno.

En este caso, el vector de la restriccion (R) sera (0,1,1) al querer restringir los coeficientes $\beta_1$ y $\beta_2$

```{r,echo=TRUE}
R<-c(0,1,1)

```

El resultado de la restriccion (r) debe ser uno

```{r,echo=TRUE}
r<-matrix(c(1))
```

Tomamos los coeficientes sin restringir

```{r,echo=TRUE}
beta<-matrix(reg$coefficients)
```

y Construimos la matriz "delt"

```{r}
delt<-t(R)%*%beta-r
```


```{r,echo=TRUE,warning=FALSE}
rls(PBI~Poblacion + Capital ,r,R,delt,data=base)
```

<h2>Predicción de Y cuando usamos ln(Y) como la variable dependiente</h2>

Wooldridge Pag 212 Ejemplo 6.7 Pag 214

Si partimos del modelo 

$$ln (Y) = \beta_{0}+\beta_{1}*X_{1}+...+\beta_{k}*x_{k}+u$$
Al realizar el pronostico sobre esta funcion es calcular el valor de $\hat y$ y luego exponenciarlo. Pero lo que se sucede en realidad es que este metodo **_subestima el valor esperado de Y_**.

Esto sucede ya que, al exponenciar la variable dependiente y cumpliendo con los supuestos, la prediccion queda:

$$E(Y|x)=exp(\sigma^2/2)*exp(\beta_{0}+\beta_{1}*X_{1}+...+\beta_{k}*x_{k})$$

$$\hat y=exp(\sigma^2/2)*exp(\hat y)$$

Por lo tanto, a la expresion $exp(\sigma^2/2)$ se la considera como un factor de correccion de la estimacion y dado que siempre es mayor que uno, nos indica que las estimaciones "simples" siempre arrojan una subestimacion.

El objetivo entonces es calcular este factor al cual llamaremos $\alpha_{0}$

Si bien existen dos metodos, solo utilizaremos el Estimador no parametrico de Duan, donde:

$$\hat \alpha_{0}=\frac{\sum exp(e)}{n}$$

Es decir, $\hat \alpha_{0}$ es el promedio de los residuos exponenciados de la regresion.

1) Realizar la regresion Log-Lin del modelo planteado.

2) Exponenciar los residuos y calcular su promedio.

Para ejemplificar esto, haremos el ejercicio 6.7 pag 214

Vemos la regresion planteada

```{r}
reg5<-lm(log(salary)~log(sales)+log(mktval)+ceoten,data=ceosal2)
summary(reg5)
```
Ahora realicemos una estimacion sencilla para un nivel de ventas (sales) de 5.000, valor de mercado de 10.000 (mktval) y ceoten de 10.

```{r}
pred<-data.frame(sales=5000,mktval=10000,ceoten=10)
prediccion<-predict(reg5,newdata=pred)
a<-data.frame(Ventas=5000,Mercado=10000,ceoten=10,Prediccion=prediccion,"Exp Prediccion"=exp(prediccion))
kable(a,align="c")%>%
  kable_styling(bootstrap_options=c("striped","borderer"), full_width = F)
```

```{r}
alfa<-mean(exp(reg5$residuals))
```

Calculamos ahora el factor de correccion $\hat \alpha_{0}$ como el promedio de los residuos y luego exponenciados.

```{r}
a<-data.frame(Ventas=5000,Mercado=10000,ceoten=10,Prediccion=prediccion,"Exp Prediccion"=exp(prediccion),Alfa=alfa,"Pred Corregida"=alfa*exp(prediccion))
kable(a,align="c")%>%
  kable_styling(bootstrap_options=c("striped","borderer"), full_width = F)
```

El factor de correccion nos indica que la estimacion "simple" esta subestimada en casi un 13%.

<h1>2 - Modelo Reciproco</h1>

El modelo Reciproco es aquel que tiene la forma $Y_{?}~=~\beta_{0}~+~\beta_{1}~*~(\frac{1}{X})+~e_{i}$

Uno de los modelos mas conocidos dentro de la Macroeconomia es la Curva de Phillips que relaciona la tasa de desempleo y la tasa de inflación.

Para este modelo usaremos dos ejemplos:

 + Tomaremos de Gujarati Pag 171 Tabla 6.5 los datos de EEUU.
 + Luego tomaremos los datos del Desempleo y del IPC de Argentina, los datos del desempleo son trimestrales y los datos del IPC son mensuales por lo que se adaptaron los datos del IPC calculando el promedio para el trimestre, para el periodo comprendido entre 2007 y 2015, se utilizo el IPC San Luis debido a los conocidos problemas con del IPC Indec.

La idea es realizar dos regresiones, la "lineal" sobre los datos originales y luego la transformación reciproca para luego graficar las observaciones y los ajustes.

```{r,echo=TRUE}

phillips<-formas[1:47,14:15]   #Tomamos los datos

#Generamos la variable incremento interanual de la inflacion
phillips$Inc<-c(0,phillips$Inflacion[2:47]-phillips$Inflacion[1:46])


plot(phillips$Desempleo,phillips$Inc,pch=19,col="red",          #Hacemos el grafico de los datos
     xlab="Tasa de Desempleo (%)",ylab="Variacion Inflacion",
     main="Curva de Phillips modificada por expectativas",ylim=c(-5,5),yaxt="n")
axis(2,at=seq(-5,5,1),labels = seq(-5,5,1),las=1)
abline(h=0,col="blue",lwd=2)
```

Hacemos la regresión

```{r}
ols_regress(Inc~Desempleo,data=phillips)
coef<-summary(lm(Inc~Desempleo,data=phillips))$coefficients[,1]
```

Con estos datos podemos calcular la **_tasa natural de desempleo_** como $\frac{\hat \beta_0}{-\hat \beta_1}$

$$U^N=\frac{`r coef[1]`}{`r coef[2]`}=`r coef[1]/ -coef[2]`$$

Veamos las observaciones y las observaciones transformadas

```{r,echo=FALSE}
phillips<-read.table("Curva de Phillips.txt",header=TRUE)
attach(phillips)
reg8<-lm(Inflacion~Desempleo);summary(reg8)
I.desempleo<-1/Desempleo
reg9<-lm(Inflacion~I.desempleo);summary(reg9)
x<-seq(5,20,length=76)
preda<-predict(reg8,data.frame(Desempleo=x))
predb<-predict(reg9,data.frame(I.desempleo=1/x))
```
```{r,echo=FALSE}
plot(phillips$Desempleo,phillips$Inflacion, pch=19, col="blue",xlab = "Desempleo",ylab="Inflacion",main="Curva de Phillips")
plot(phillips$Desempleo,1/phillips$Inflacion, pch=19, col="blue",xlab = "Desempleo",ylab="Inflacion",main="Datos Transformados")
```

```{r,echo=FALSE}
matplot(x,cbind(preda,predb),lty=c(3,2),lwd=2,col=c("red","blue"),type = "l",xlim=c(5,22),ylim = c(0,20),xlab="Desempleo",ylab="Inflacion",main="Comparacion de Ajustes",xaxs="i")
points(Desempleo,Inflacion,pch=20,col="green4")
legend(x="topright", c("Lineal","Reciproco","Observaciones"), lty=c(3,2,NA),pch=c(NA,NA,19),col=c("red","blue","green4"),cex=0.8,bty="n")
```

<h1>3 - Modelos Polinomiales</h1>

El mas conocido de los modelos polinomiales es la funcion de corto plazo del Costo Medio y Costo Total dentro de una empresa.

Para esto vamos a utilizar el ejercicio 7.4 de la pagina 211 del libro de Gujarati.
Lo primero como siempre es ver los datos, realizar las graficas y luego generar las salidas de las regresiones.

```{r,echo=FALSE}
datos<-matrix(c(1,193,2,226,3,240,4,244,5,257,6,260,7,274,8,297,9,350,10,420),nrow = 10,byrow = T)
Costo.medio<-datos[,2]/datos[,1]
empresa<-round(data.frame(datos,Costo.medio),digits = 3)
colnames(empresa)<-c("Produccion","Costo.Total","Costo.Medio")
attach(empresa)
```

```{r,echo=FALSE}
kable(empresa,align="c")%>%
  kable_styling(bootstrap_options=c("striped","borderer"), full_width = F)
```

Vamos a realizar primero el analisis sobre el costo Total haciendo las regresion de tres formas distintas y haremos las tres graficas de los valores estimados para ver que funcion ajusta mejor.


```{r,echo=FALSE}
reg1<-lm(Costo.Total~Produccion)
reg2<-lm(Costo.Total~Produccion+I(Produccion^2))
reg3<-lm(Costo.Total~Produccion+I(Produccion^2)+I(Produccion^3))

plot(empresa[,1],empresa[,2],xlab="Produccion",ylab = "Costo Total",pch=19, col="red",cex.axis=.8,main="Costo Total",xlim=c(0,10),ylim = c(180,440))
par(new=TRUE)
plot(Produccion,reg1$fitted.values,xlim=c(0,10),ylim = c(180,440),col="blue",type = "l",lwd=2,xlab="",ylab="",axes = F)
par(new=TRUE)
plot(Produccion,reg2$fitted.values,xlim=c(0,10),ylim = c(180,440),col="green4",type = "l",lwd=2,xlab="",ylab="",axes = F)
par(new=TRUE)
plot(Produccion,reg3$fitted.values,xlim=c(0,10),ylim = c(180,440),col="orange",type = "l",lwd=2,xlab="",ylab="",axes = F)
legend("topleft",legend = c("Datos","Lineal","Cuadratica","Polinomica"),bty="n",pch=c(19,19,19,19),col = c("red","blue","orange","green4"))
```

Ahora veamos las tres tablas de coeficientes

```{r,echo=FALSE}
summary(reg1)
summary(reg2)
summary(reg3)
```

Esto mismo vamos a hacer ahora sobre el costo medio

```{r}
reg4<-lm(Costo.Medio~Produccion)
reg5<-lm(Costo.Medio~Produccion+I(Produccion^2))
reg6<-lm(Costo.Medio~Produccion+I(Produccion^2)+I(Produccion^3))

plot(empresa[,1],empresa[,3],xlab="Produccion",ylab = "Costo Medio",pch=19, col="red",cex.axis=.8,main="Costo Medio",xlim=c(0,10),ylim = c(40,200))
par(new=TRUE)
plot(Produccion,reg4$fitted.values,xlim=c(0,10),ylim = c(40,200),col="blue",type = "l",lwd=2,xlab="",ylab="",axes = F)
par(new=TRUE)
plot(Produccion,reg5$fitted.values,xlim=c(0,10),ylim = c(40,200),col="green4",type = "l",lwd=2,xlab="",ylab="",axes = F)
par(new=TRUE)
plot(Produccion,reg6$fitted.values,xlim=c(0,10),ylim = c(40,200),col="orange",type = "l",lwd=2,xlab="",ylab="",axes = F)
legend("topleft",legend = c("Datos","Lineal","Cuadratica","Cubica"),bty="n",pch=c(19,19,19,19),col = c("red","blue","orange","green4"))
```

Ahora veamos las tres tablas de coeficientes

```{r,echo=FALSE}
summary(reg4)
summary(reg5)
summary(reg6)
```

<div class="tocify-extend-page" data-unique="tocify-extend-page" style="height: 0;"></div>